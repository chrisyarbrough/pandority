namespace Pandority
{
	using System;
	using System.Diagnostics;
	using System.IO;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Threading;
	using static System.Environment;

	/// <summary>
	/// Represents an instance of a log file.
	/// </summary>
	/// <remarks>
	/// The class uses lazy initialization to avoid performance penalties when it is unused.
	/// <p/>
	/// Roslyn generators are spawned by multiple processes (e.g. Unity and Rider) and each runs on multiple threads
	/// in parallel. To avoid concurrency issues in a simple way, each generator type writes to its own file.
	/// Multiple processes of the same generator type will overwrite each other's files (only the most recently run
	/// generator output will be preserved). Multiple threads of the same generator will append to the same file.
	/// </remarks>
	internal sealed class Log
	{
		private readonly string fileName;

		// The mutex ensures that file writes are atomic between processes and threads. This still means that
		// different processes will overwrite each other's files, but a new file will not, for example, end up
		// with half a line of the previous file's content.
		private readonly Mutex mutex;
		private readonly bool isMutexOwner;

		private StreamWriter? writer;

		/// <summary>
		/// Creates a new log file instance.
		/// </summary>
		/// <param name="fileName">The file name including its extension.</param>
		public Log(string fileName)
		{
			this.fileName = fileName;
			this.mutex = new(initiallyOwned: false, fileName, out isMutexOwner);
		}

		~Log()
		{
			if (isMutexOwner)
				mutex.Dispose();

			writer?.Dispose();
		}

		[Conditional("DEBUG")]
		public void Debug(string message)
		{
			// Because multiple assemblies can be processed in parallel, this helps differentiate between them.
			Write($"{Thread.CurrentThread.ManagedThreadId}: {message}");
		}

		public void Exception(Exception exception)
		{
			Write(exception);
		}

		private void Write(object value)
		{
			try
			{
				mutex.WaitOne();

				writer = EnsureInitializedWriter(ref writer);
				writer.WriteLine(value);
			}
			catch (AbandonedMutexException ex)
			{
				// Another generator process has crashed before releasing the mutex.
				ex.Mutex?.ReleaseMutex();
			}
			finally
			{
				mutex.ReleaseMutex();
			}
		}

		private StreamWriter EnsureInitializedWriter(ref StreamWriter? writer)
		{
			if (writer != null)
				return writer;

			string logFilePath = InitializeLogFile();

			writer = File.CreateText(logFilePath);
			writer.AutoFlush = true;

			// Help to identify whether the current log originates from Unity or the IDE.
			writer.WriteLine("Entry assembly: " + Assembly.GetEntryAssembly()?.Location);
			return writer;
		}

		private string InitializeLogFile()
		{
			string logDirectory = GetLogDirectory();
			Directory.CreateDirectory(logDirectory);

			string logFilePath = Path.Combine(logDirectory, fileName);
			if (File.Exists(logFilePath))
				File.Delete(logFilePath);

			return logFilePath;
		}

		/// <summary>
		/// Follows the convention for log files generated by Unity.
		/// </summary>
		private static string GetLogDirectory()
		{
			// This follows the convention of the Unity log files.
			if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
				return GetFolderPath(SpecialFolder.UserProfile) + "/Library/Logs/Pandority";

			else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
				return GetFolderPath(SpecialFolder.LocalApplicationData) + "\\Pandority";

			else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
				return GetFolderPath(SpecialFolder.UserProfile) + "/.config/Pandority";

			throw new NotSupportedException("Unsupported platform.");
		}
	}
}
